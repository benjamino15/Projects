library(ggplot2)
library(gridExtra)
library(tidyr)

#Manually changed the csv file to add variable names
df <- read.csv("marketing_data.csv")
df <- cbind(1:2443, df)
colnames(df) <- c("index","sales", "gexp", "yexp")


df_wide <- cbind(gather(df[, c("gexp", "yexp")], factor_key = TRUE), rep(df$index, 2))
colnames(df_wide)[3] <- "index"
colnames(df_wide)[1] <- "legend"

plot_list <- list()

  plot_list[[1]] <- ggplot(df, aes(x = index, y = sales, group = 1))+ 
    geom_line(size = 0.5) + theme_bw() + 
    labs(y = "$", x = "time (hours)", title= "Sales volume")

     
plot_list[[2]] <- ggplot(df_wide) + aes(x = index, y = value) + 
  geom_line(aes(color = legend), size = 0.5) +
  scale_color_manual(values = c("#00A4CCFF", "#F95700FF"), 
                     breaks = c("gexp", "yexp"),
                     labels = c("Google", "YouTube")) +
  labs(y = "$", x = "time (hours)", title= "Expenditure in Google advertising vs. YouTube") +
  theme_bw()

grid.arrange(grobs=plot_list,ncol=2, nrow = 1)
#Export with width = 1100 and height = 400

#QUESTION 2

#theta <- (μ,φ1,φ2,δ1,δ2,α1,α2,β1,β2)
theta_ini <-  c(1,1,1,0.5,0.5,5,5,0.9,0.9)

least_square <-  function(theta, df){
  gads <-  rep(0,nrow(df))
  yads <-  rep(0,nrow(df))
  s    <-  rep (0,nrow(df))
  
  for (i in 1:(nrow(df)-1)){
  gads[i+1] <- theta[8]*gads[i]+ theta[6]*df[[i+1,3]]
  yads[i+1] <- theta[9]*yads[i]+theta[7]*df[[i+1,4]]
  s[i+1] <-theta[1]+theta[2]*(gads[i+1])^theta[4] + theta[3]*(yads[i+1])^theta[5]
  }
  #Formula of LS starts at t=2
  dif <- rep(0,(nrow(df)-1))

  for (t in 2:nrow(df)){
  dif[t-1]<-  (df[[t,2]] -s[t])^2
  }
  
  ls <- (1/(nrow(df)-1))* sum(dif)
  return(ls)
}

ls_opt <- optim(fn=least_square,
                par= theta_ini,
                lower = c(0,0,0,0,0,0,0,0,0),
                upper= c(Inf,Inf,Inf,1,1,Inf,Inf,1,1),
                method="L-BFGS-B",
                df=df)
ls_opt$par

#QUESTION 3

theta_est <- ls_opt$par
gads_est <-  rep(0,nrow(df)-1)
yads_est <-  rep(0,nrow(df)-1)

for (i in 1:(nrow(df)-1)){
  gads_est[i+1] <- theta_est[8]*gads_est[i]+ theta_est[6]*df[[i+1,3]]
  yads_est[i+1] <- theta_est[9]*yads_est[i]+theta_est[7]*df[[i+1,4]]
}

 ggplot(data=df)+
   geom_line(aes(x=index, y=gads_est, col="Google"))+
   geom_line(aes(x=index, y=yads_est, col="Youtube"))+
   scale_colour_manual(name = "Adstock",
                       values=c("Google"="#00A4CCFF","Youtube"="#F95700FF"))+
   theme_bw()+
   labs(title="Adstock generated by Google and Youtube",x = "Hours",y = "Adstock")
 
 #QUESTION 4

 
 s = 3 # Set shock time s
 sales0 = theta_est[1] # Set origin value
 yads0 = 0
 
 e = 100 # Set shock size e
 h = 100 # Set steps ahead
 
 # Generate IRF
 
 #for t<s
 yads_path <- matrix(0, s+h, 1)
 sales_path <- matrix(theta_est[1], s+h, 1)

 #for t=s
 yads_path[s,] = theta_est[9]*yads_path[s-1,] + theta_est[7]*e
 sales_path[s,] = theta_est[1] + theta_est[3]*yads_path[s,]^theta_est[5]
 
 # for t>s
 for (t in (s+1):(s+h)) {
   yads_path[t,] = theta_est[9]*yads_path[t-1,] + theta_est[7]*0
   sales_path[t,] = theta_est[1] + theta_est[3]*yads_path[t,]^theta_est[5]
 }

## Plot
 h_ax = 1:(h+s)

df_yads <- as.data.frame(cbind(h_ax, yads_path))
df_sales <- as.data.frame(cbind(h_ax, sales_path))


plot_list <- list()

plot_list[[1]] <- ggplot() + theme_bw() +
  geom_line(data = df_yads, aes(x = h_ax, y = yads_path), color = "black") + 
  labs(y = "Adstock", x = "time (hours)", title= "IRF for YouTube adstock")
plot_list[[2]] <- ggplot() + theme_bw() + 
  geom_line(data = df_sales, aes(x = h_ax, y = sales_path), color = "black") + 
  labs(y = "$", x = "time (hours)", title= "IRF for Sales")

grid.arrange(grobs=plot_list,ncol=1, nrow = 2)

# Question 6

# set h large enough to find the period at which sales goes back to its pre-shock value 
h = 1000

# rerun same code as in Q4
# Generate IRF

#for t<s
sales_pathQ6 <- matrix(theta_est[1], s+h, 1)
yads_pathQ6 <- matrix(0, s+h, 1)

#for t=s
yads_pathQ6[s] = theta_est[9]*yads_pathQ6[s-1,] + theta_est[7]*e
sales_pathQ6[s] = theta_est[1] + theta_est[3]*yads_pathQ6[s,]^theta_est[5] 

# for t>s
for (t in (s+1):(s+h)) {
  yads_pathQ6[t] = theta_est[9]*yads_pathQ6[t-1,] + theta_est[7]*0
  sales_pathQ6[t] = theta_est[1] + theta_est[3]*yads_pathQ6[t,]^theta_est[5]
}

sales_pathQ6<- sales_pathQ6[-c(1:2),]
sum_sales <- matrix(NA, h, 1)
i = 1
while(sales_pathQ6[i] > theta_est[1] + 0.0001)
  {
  sum_sales[i] <- (sales_pathQ6[i] - theta_est[1])
  i = i + 1
}

sum(sum_sales, na.rm = TRUE)


#Question 7

e = 300

# rerun same code as in Q6
# Generate IRF

#for t<s
sales_pathQ7 <- matrix(theta_est[1], s+h, 1)
yads_pathQ7 <- matrix(0, s+h, 1)

#for t=s
yads_pathQ7[s] = theta_est[9]*yads_pathQ7[s-1,] + theta_est[7]*e
sales_pathQ7[s] = theta_est[1] + theta_est[3]*yads_pathQ7[s,]^theta_est[5] 

# for t>s
for (t in (s+1):(s+h)) {
  yads_pathQ7[t] = theta_est[9]*yads_pathQ7[t-1,] + theta_est[7]*0
  sales_pathQ7[t] = theta_est[1] + theta_est[3]*yads_pathQ7[t,]^theta_est[5]
}

sales_pathQ7<- sales_pathQ7[-c(1:2),]
sum_sales <- matrix(NA, h, 1)
i = 1
while(sales_pathQ7[i] > theta_est[1] + 0.0001)
{
  sum_sales[i] <- (sales_pathQ7[i] - theta_est[1])
  i = i + 1
}

sum(sum_sales, na.rm = TRUE)


########### Second part of the assignment 

### Assigment 4 ###
rm(list=ls())

library(dplyr); library(Matrix); library(matrixcalc); library(matlib)
library(ivreg); library(tidyverse); library(ggpubr)

#Upload data
my_data <- read.csv("pricing_data.csv")

###Question 9###

my_data <- my_data %>% mutate(hundred_units_sales = (my_data$s)/100)

ts.plot(my_data$hundred_units_sales, xlab="Days", ylab="Hundred of units saled", main="Evolution in Sales")

ts.plot(my_data$p, xlab = "Days", ylab = "Price valuation", main = "Evolution in Selling Price")

ts.plot(my_data$c, xlab = "Days", ylab = "Acquicition cost", main = "Evolution in Acquisition Cost")

my_data <- my_data %>% mutate(tens_marketing = (my_data$m)/10)

ts.plot(my_data$tens_marketing, xlab = "Days", ylab = "Tens of monetary units", main = "Evolution in Marketing Expenditure")

###Question 10###

simp_regr <- lm(s~p, data=my_data)

summary(simp_regr)

##Export results

Q10 <- matrix(0,ncol=1,nrow=2); colnames(Q10) = c("Estimate")

Q10[,1] <- simp_regr$coefficients

write.csv(Q10, file = "Tabl10.csv")


###Question 11###

#Comment on that

###Question 12###

#Comment on that

###Question 13###

instr_regr <- lm(p~c,data=my_data)
twoSLS<- lm(s~fitted(instr_regr),data=my_data)
sales_regr <- ivreg(s~p|c,data=my_data)

summary(instr_regr)
summary(twoSLS)
summary(sales_regr)

##Export results p_hat

p_hat <- matrix(0,ncol=1,nrow=2); colnames(p_hat) = c("Estimate")

p_hat[,1] <- instr_regr$coefficients

write.csv(p_hat, file = "p_hat.csv")

##Export results 2SLS

Q13 <- matrix(0,ncol=1,nrow=2); colnames(Q13) = c("Estimate")

Q13[,1] <- twoSLS$coefficients

write.csv(Q13, file = "Tabl13.csv")

###Question 14###


###create data matrix
intercept <- rep(1, nrow(my_data))
x <- as.matrix(cbind(intercept,my_data$p))
iv <- as.matrix(cbind(intercept,my_data$c))
fitted_x <- as.matrix(cbind(intercept,fitted(instr_regr)))

y <- as.matrix(my_data$s)
XX <- solve(t(x) %*% x)
ZZ<- (t(iv)%*%iv)
ZX<- solve(t(iv)%*%x)
XZ <- solve(t(x)%*%iv)
res_ols <- y - x %*% simp_regr$coefficients
res_iv <- y - x %*% twoSLS$coefficients
degr_freedom= nrow(y)-ncol(x)
var_residuals_ols <- sum(res_ols^2)/degr_freedom
var_residuals_iv <- sum(res_iv^2)/degr_freedom
cov_ols <- var_residuals_ols*XX
cov_iv <- var_residuals_iv*(ZX%*%ZZ%*%XZ)
dif_cov<- inv(cov_iv-cov_ols)

rankMatrix(dif_cov)
test_statistic<-nrow(my_data)*(t((twoSLS$coefficients-simp_regr$coefficients))%*%dif_cov%*%(twoSLS$coefficients-simp_regr$coefficients))
test_statistic
df<- rankMatrix(dif_cov)

Hausman_test <- function(value,df){ 
  if(value > qchisq(0.95,df)){
    return("Reject the Null hypothesis, there is sufficient evidence for endogeneity on a 5 percent significance level")
    
  }else{
    return("There is no evidence for endogeneity")
  }
}
Hausman_test(test_statistic,df)

###Question 15###

improved_sales_model <- lm(s~fitted(instr_regr)+m,data=my_data)
summary(improved_sales_model)

##Export results 

Q15 <- matrix(0,ncol=1,nrow=3); colnames(Q15) = c("Estimate")

Q15[,1] <- improved_sales_model$coefficients

write.csv(Q15, file = "Tabl15.csv")

###Question 16###

##Build a matrix

Q16 <- matrix(0,nrow = nrow(my_data), ncol = 3); colnames(Q16) = c("E[pi|c]","E[s]","p-c")

Q16[,3] = my_data$p - my_data$c

Q16[,2] = Q15[1,1] + Q15[2,1]*my_data$p + Q15[3,1]*my_data$m

Q16[,1] = Q16[,2]*Q16[,3]

##Answering the question

#Last_proff <- expression((Q15[1,1] + Q15[2,1]*PT + Q15[3,1]*MT)*(PT - CT))

Last_proff <- expression((51265.64 - 17.42922*PT + 0.04489404*MT)*(PT - CT))

#Effect

Effect <- D(Last_proff, "PT")

#Last Values

PT <- my_data$p[759]; MT <- my_data$m[759]; CT <- my_data$c[759]

num_effect <- (51265.64 - 17.42922 * PT + 0.04489404 * MT) - 17.42922 * (PT - CT)

if(num_effect > 0){
  print("Effect of price on benefits is positive, i.e., I recommend to increase the price")
}else{
  print("Effect of price on benefits is negative, i.e., I recommend to decrease the price")
}



